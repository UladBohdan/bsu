\section{Метад паслядоўнага павышэння парадка дакладнасці}
\subsection*{Ураўненне}
Для ўраўнення мы будзем выкарыстоўваць метад паслядоўнага павышэння парадка дакладнасці 3-га парадка дакладнасці ($O(h^{4})$). Для набліжэння значэнняў інтэгралаў будзем выкарыстоўваць формулу трапецыяў. Атрымліваем наступныя формулы:
\[ y_{n+1}^{[4]} = y_n^{[4]} + \frac{h}{6}(f_n^{[4]} + 4f_{n+\frac{1}{2}}^{[3]} + f_{n+1}^{[3]}) \]
\[ y_{n+1}^{[3]} = y_n^{[4]} + \frac{h}{2}(f_n^{[4]} + f_{n+1}^{[2]}) \]
\[ y_{n+1}^{[2]} = y_n^{[4]} + hf_n^{[4]} \]
\[ y_{n+\frac{1}{2}}^{[3]} = y_n^{[4]} + \frac{h}{4}(f_n^{[4]} + f_{n+\frac{1}{2}}^{[2]}) \]
\[ y_{n+\frac{1}{2}}^{[2]} = y_n^{[4]} + \frac{h}{2}f_n^{[4]}, \hspace{15pt} h = \frac{x_1-x_0}{N}, \hspace{10pt} n = \overline{0, N-1}. \]

{\small
\begin{verbatim}
def predictor_corrector():
    yi4 = [u0]
    for i in range(1, len(grid)):
        step = grid[i] - grid[i-1]
        y_n4_2 = yi4[i-1] + step * f(grid[i-1], yi4[i-1]) / 4.
        y_n2_3 = yi4[i-1] + step * f(grid[i-1] + step / 4., y_n4_2) / 2.
        y3 = yi4[i-1] + step * f(grid[i-1] + step / 2., y_n2_3)
        y4 = yi4[i-1] + step * ( f(grid[i-1], yi4[i-1]) +
                4 * f(grid[i-1] + step/2., y_n2_3) + f(grid[i], y3) ) / 6.
        yi4.append(y4)
    return yi4
\end{verbatim}
}

{\small
\begin{verbatim}
Predictor-corrector:
y(0.0) = -1
y(0.1) = -0.900167599506
y(0.2) = -0.801332483673
y(0.3) = -0.704482201153
y(0.4) = -0.610584474262
y(0.5) = -0.520577527809
y(0.6) = -0.43536071269
y(0.7) = -0.355785518045
y(0.8) = -0.282647061914
y(0.9) = -0.216676145457
y(1.0) = -0.158531950178
\end{verbatim}
}

\subsection*{Сістэма}
Сістэму метадам прэдыктар-карэктар будзем рашаць з 2-ім парадкам дакладнасці ($O(h^{3})$), то бок справядлівыя формулы:
\[ y_{n+1}^{[3]} = y_n^{[3]} + \frac{h}{2}(f_n^{[3]} + f_{n+1}^{[2]}) \]
\[ z_{n+1}^{[3]} = z_n^{[3]} + \frac{h}{2}(g_n^{[3]} + g_{n+1}^{[2]}) \]
\[ y_{n+1}^{[2]} = y_n^{[3]} + hf_n^{[3]} \]
\[ z_{n+1}^{[2]} = z_n^{[3]} + hg_n^{[3]}, \hspace{15pt} h = \frac{x_1-x_0}{N}, \hspace{10pt} n = \overline{0, N-1}. \]

{\small
\begin{verbatim}
def predictor_corrector_system():
    yi3 = [y0]
    zi3 = [z0]
    for i in range(1, len(grid)):
        step = grid[i] - grid[i-1]

        y2 = yi3[i-1] + step * f(grid[i-1], yi3[i-1], zi3[i-1])
        y3 = yi3[i-1] + step * (f(grid[i-1], yi3[i-1], zi3[i-1]) + f(grid[i], y2, zi3[i-1])) / 2.
        yi3.append(y3)

        z2 = zi3[i-1] + step * g(grid[i-1], yi3[i-1], zi3[i-1])
        z3 = zi3[i-1] + step * (g(grid[i-1], yi3[i-1], zi3[i-1]) + g(grid[i], yi3[i-1], z2)) / 2.
        zi3.append(z3)
    return (yi3, zi3)
\end{verbatim}
}

{\small
\begin{verbatim}
Predictor-corrector for system:
Y:
y(0.0) = 0.5
y(0.05) = 0.516721916223
y(0.1) = 0.536121101104
y(0.15) = 0.558296358137
y(0.2) = 0.583404263928
y(0.25) = 0.611655373195
y(0.3) = 0.643304953647
y(0.35) = 0.678637891004
y(0.4) = 0.717948576343
y(0.45) = 0.761518135242
y(0.5) = 0.809592858914
Z:
z(0.0) = 1.0
z(0.05) = 1.076875
z(0.1) = 1.15943250147
z(0.15) = 1.24831456526
z(0.2) = 1.34423940614
z(0.25) = 1.44801863056
z(0.3) = 1.56057712067
z(0.35) = 1.6829754276
z(0.4) = 1.81643423044
z(0.45) = 1.96236012598
z(0.5) = 2.12237184414
\end{verbatim}
}
